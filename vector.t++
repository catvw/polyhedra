#ifndef VECTOR_TXX
#define VECTOR_TXX

#include <cstddef>
#include <cmath>
#include <ostream>
#include <type_traits>
#include <array>

template <std::size_t D>
class vector;

/* forward declarations to tell the class these are templates */
template <std::size_t D>
vector<D> operator+(vector<D>, const vector<D>&);
template <std::size_t D>
vector<D> operator-(vector<D>, const vector<D>&);

/**
 * Simple vector class for my ridiculous polyhedron modeler.
 *
 * @author Charles Van West
 */
template <std::size_t D>
class vector {
public:
    vector();
    
    template <typename... A>
    vector(const A...);
    
    /**
     * Accesses vector members by index.
     *
     * @param the index
     */
    double& operator[](const std::size_t);
    const double& operator[](const std::size_t) const;
    
    friend vector<D> operator+ <> (vector<D>, const vector<D>&);
    friend vector<D> operator- <> (vector<D>, const vector<D>&);
    
    /**
     * Finds the dot-product of two vectors.
     */
    double operator*(const vector<D>&) const;
    
    /**
     * Gets the absolute value (length) of the vector.
     */
    double operator()() const;
    
    /**
     * Gets the absolute angle between this vector and another one in radians.
     */
    double angle(const vector<D>&) const;
private:
    struct flag { std::size_t index = 0; };
    
    template <typename T>
    void build(flag, const T);
    
    template <typename T,
              typename... A>
    void build(flag, const T, const A...);
    
    double v[D];
};

template <std::size_t D>
inline vector<D>::vector() {
    for (int i = 0; i < D; ++i) {
        v[D] = 0;
    }
}

template <std::size_t D>
template <typename... A>
inline vector<D>::vector(const A... args) {
    static_assert(sizeof...(A) == D, "error: invalid number of arguments to constructor");
    build(flag(), args...);
}

template <std::size_t D>
template <typename T>
inline void vector<D>::build(flag f, const T next) {
    static_assert(std::is_arithmetic<T>::value, "error: T not an arithmetic type");
    v[f.index] = next;
}

template <std::size_t D>
template <typename T,
          typename... A>
inline void vector<D>::build(flag f, const T next, const A... args) {
    static_assert(std::is_arithmetic<T>::value, "error: T not an arithmetic type");
    v[f.index++] = next;
    build(f, args...);
}

template <std::size_t D>
inline double& vector<D>::operator[](const std::size_t index) {
    return v[index];
}

template <std::size_t D>
inline const double& vector<D>::operator[](const std::size_t index) const {
    return v[index];
}

template <std::size_t D>
inline vector<D> operator+(vector<D> lh, const vector<D>& rh) {
    for (int i = 0; i < D; ++i) {
        lh.v[i] += rh.v[i];
    }
    return lh;
}

template <std::size_t D>
inline vector<D> operator-(vector<D> lh, const vector<D>& rh) {
    for (int i = 0; i < D; ++i) {
        lh.v[i] -= rh.v[i];
    }
    return lh;
}

template <std::size_t D>
inline double vector<D>::operator*(const vector<D>& rh) const {
    double product = 0;
    for (int i = 0; i < D; ++i) {
        product += v[i] * rh.v[i];
    }
    return product;
}

template <std::size_t D>
inline double vector<D>::operator()() const {
    double sum = 0;
    for (int i = 0; i < D; ++i) {
        sum += v[i] * v[i];
    }
    return sqrt(sum);
}

template <std::size_t D>
inline double vector<D>::angle(const vector<D>& rh) const {
    return std::abs(std::acos(((*this) * rh) / ((*this)() * rh())));
}

/**
 * Writes a vector to an ostream for easy printing.
 */
template <std::size_t D>
std::ostream& operator<<(std::ostream& os, const vector<D>& v) {
    os << '<';
    if (D > 0) {
        os << v[0];
        for (std::size_t i = 1; i < D; ++i) {
            os << ", " << v[i];
        }
    }
    os << '>';
    return os;
}

#endif /* VECTOR_TXX */
